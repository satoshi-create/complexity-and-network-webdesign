<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¼ Sound Pattern Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 2em;
      background: #f7f7f7;
    }

    button {
      margin: 1em;
      padding: 1em 2em;
      font-size: 1rem;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .prediction-area {
      margin: 1.5em;
      padding: 1em;
      border-radius: 8px;
    }

    .category {
      font-size: 1.2rem;
      font-weight: bold;
      margin: 0.5em;
    }
  </style>
</head>

<body>
  <h1>ğŸµ Sound Pattern Generator</h1>
  <p>Click to play a generated pattern and give feedback</p>
  <div class="prediction-area">
    <div id="category-display" class="category">ğŸ”® Category: --</div>
    <div id="score-display">ğŸ¯ Score: --</div>
  </div>
  <button id="playButton">ğŸ”Š Play Pattern</button>
  <button id="likeButton">ğŸ‘ Like</button>
  <button id="dislikeButton">ğŸ‘ Dislike</button>

  <script>
    const synth = new Tone.Synth().toDestination();
    const notes = ["C4", "D4", "E4", "G4", "A4"];

    // Sound categories with emojis
    const soundCategories = [
      { name: "Beat", emoji: "ğŸ¥" },
      { name: "Melody", emoji: "ğŸµ" },
      { name: "Chime", emoji: "ğŸ””" }
    ];

    // Button elements
    const playButton = document.getElementById("playButton");
    const likeButton = document.getElementById("likeButton");
    const dislikeButton = document.getElementById("dislikeButton");

    let pattern = [0, 2, 4, 3, 1]; // åˆæœŸã®éŸ³ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆéŸ³éšã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
    let trainingData = []; // å­¦ç¿’ç”¨ã®å…¥åŠ›ãƒ‘ã‚¿ãƒ¼ãƒ³
    let trainingLabels = [];  // ãƒ©ãƒ™ãƒ«ï¼ˆ1 = Like, 0 = Dislikeï¼‰
    let categoriesData = []; // Sound category data for each pattern
    let patternPlayed = false; // Flag to track if a pattern was played

    // TensorFlow.js modelï¼ˆMLPï¼‰
    const model = tf.sequential();
    model.add(tf.layers.dense({ inputShape: [5], units: 12, activation: 'relu' })); // å…¥åŠ›å±¤ â†’ ä¸­é–“å±¤ï¼ˆ5å…¥åŠ› â†’ 12ãƒ¦ãƒ‹ãƒƒãƒˆï¼‰
    model.add(tf.layers.dense({ units: 8, activation: 'relu' })); // Additional layer for better pattern recognition
    model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' })); // å‡ºåŠ›å±¤ï¼ˆ1ãƒ¦ãƒ‹ãƒƒãƒˆï¼šç¢ºç‡ã¨ã—ã¦å¥½ã¿ã‚’äºˆæ¸¬ï¼‰
    model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy' }); // æå¤±é–¢æ•°ã¨æœ€é©åŒ–æ‰‹æ³•ã‚’æŒ‡å®š

    // Category classifier model - separate from preference model
    const categoryModel = tf.sequential();
    categoryModel.add(tf.layers.dense({ inputShape: [5], units: 10, activation: 'relu' }));
    categoryModel.add(tf.layers.dense({ units: soundCategories.length, activation: 'softmax' })); // Output one probability per category
    categoryModel.compile({ optimizer: 'adam', loss: 'categoricalCrossentropy' });

    // Initialize button states
    setFeedbackButtonsState();

    // ğŸµ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†ç”Ÿ
    function playPattern() {
      let time = 0;
      pattern.forEach(index => {
        Tone.Transport.scheduleOnce(t => {
          synth.triggerAttackRelease(notes[index], "8n", t);
        }, `+${time}`);
        time += 0.5;
      });
      Tone.Transport.start();
      patternPlayed = true;
      setFeedbackButtonsState();
      predictPreference();
    }

    // Enable or disable the feedback buttons based on whether a pattern has been played
    function setFeedbackButtonsState() {
      likeButton.disabled = !patternPlayed;
      dislikeButton.disabled = !patternPlayed;
    }

    // ğŸ”„ æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
    function generateRandomPattern() {
      pattern = Array.from({ length: 5 }, () => Math.floor(Math.random() * notes.length));
      patternPlayed = false;
      setFeedbackButtonsState();
    }

    // ğŸ§  ãƒ¢ãƒ‡ãƒ«ã‚’å­¦ç¿’ã™ã‚‹é–¢æ•°ï¼ˆå…¥åŠ›ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒ©ãƒ™ãƒ«ï¼‰
    async function trainModel() {
      console.log("ğŸ§  Training started...");
      
      // Only train if we have sufficient data
      if (trainingData.length < 2) {
        console.log("Need more data to train");
        return;
      }
      
      const xs = tf.tensor2d(trainingData); // å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ†ãƒ³ã‚½ãƒ«ã«å¤‰æ›
      const ys = tf.tensor2d(trainingLabels, [trainingLabels.length, 1]);// ãƒ©ãƒ™ãƒ«ã‚’ãƒ†ãƒ³ã‚½ãƒ«ã«å¤‰æ›

      console.log("ğŸ“Š Inputs:");
      xs.print();  // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ãƒ†ãƒ³ã‚½ãƒ«è¡¨ç¤º
      console.log("ğŸ“ˆ Labels:");
      ys.print();

      await model.fit(xs, ys, {
        epochs: 10,
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            console.log(`ğŸ“š Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}`);
          }
        }
      });  // 10ã‚¨ãƒãƒƒã‚¯å­¦ç¿’
      
      // Also train the category model if we have category data
      if (categoriesData.length > 0) {
        const categoryLabels = categoriesData.map(cat => {
          // One-hot encode the category
          const oneHot = Array(soundCategories.length).fill(0);
          oneHot[cat] = 1;
          return oneHot;
        });
        
        const catYs = tf.tensor2d(categoryLabels);
        await categoryModel.fit(xs, catYs, { epochs: 8 });
        catYs.dispose();
      }
      
      xs.dispose(); // ãƒ¡ãƒ¢ãƒªè§£æ”¾
      ys.dispose();
      console.log("âœ… Training complete");
    }

    // ğŸ” ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¥½ããã†ã‹ã‚’äºˆæ¸¬ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    async function predictPreference() {
      console.log("ğŸ” Predicting preference for:", pattern);
      const input = tf.tensor2d([pattern]);
      const prediction = model.predict(input);

      const score = await prediction.data(); // çµæœã¯ Promise
      const roundedScore = score[0].toFixed(3);  // å°æ•°ç‚¹ä»¥ä¸‹3æ¡ã«

      let emoji = score > 0.7 ? "ğŸ˜" : score > 0.4 ? "ğŸ˜" : "ğŸ˜•";
      document.getElementById('score-display').innerText = `${emoji} Score: ${(roundedScore * 100).toFixed(1)}%`;

      // Predict the sound category
      if (categoriesData.length > 0) {
        const categoryPrediction = categoryModel.predict(input);
        const categoryScores = await categoryPrediction.data();
        
        // Find the most likely category
        let maxIndex = 0;
        for (let i = 1; i < categoryScores.length; i++) {
          if (categoryScores[i] > categoryScores[maxIndex]) {
            maxIndex = i;
          }
        }
        
        const predictedCategory = soundCategories[maxIndex];
        document.getElementById('category-display').innerText = 
          `ğŸ”® Category: ${predictedCategory.emoji} ${predictedCategory.name}`;
        
        categoryPrediction.dispose();
      } else {
        // If no training data yet, just pick a random category for demonstration
        const randomCat = Math.floor(Math.random() * soundCategories.length);
        const category = soundCategories[randomCat];
        document.getElementById('category-display').innerText = 
          `ğŸ”® Category: ${category.emoji} ${category.name} (demo)`;
      }

      console.log(`ğŸ¯ Predicted preference score: ${score[0].toFixed(3)}`);
      input.dispose();
    }

    // ğŸ›ï¸ ãƒœã‚¿ãƒ³æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ
    playButton.addEventListener("click", async () => {
      await Tone.start();
      Tone.Transport.stop();
      Tone.Transport.cancel();
      playPattern();
    });

    likeButton.addEventListener("click", async () => {
      trainingData.push([...pattern]);  // ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¥½ã¿ã¨ã—ã¦ä¿å­˜
      trainingLabels.push(1);           // ãƒ©ãƒ™ãƒ«1 = Like
      
      // Assign a random category for now - in a real app, you'd let users select the category
      const randomCategory = Math.floor(Math.random() * soundCategories.length);
      categoriesData.push(randomCategory);
      
      await trainModel();               // å­¦ç¿’
      generateRandomPattern();          // æ–°ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
    });

    dislikeButton.addEventListener("click", async () => {
      trainingData.push([...pattern]);   // ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å«Œã„ã¨ã—ã¦ä¿å­˜
      trainingLabels.push(0);            // ãƒ©ãƒ™ãƒ«0 = Dislike
      
      // Assign a random category for now - in a real app, you'd let users select the category
      const randomCategory = Math.floor(Math.random() * soundCategories.length);
      categoriesData.push(randomCategory);
      
      await trainModel();                 // å­¦ç¿’
      generateRandomPattern();             // æ–°ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
    });
  </script>
</body>

</html>